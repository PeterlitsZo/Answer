\subsection{题面}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Time Limit}
5s

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Memory Limit}
128M

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{题目}
LFgg有一间非常大非常大非常大的大别墅。

这天，LFgg突然特别特别特别想吃韭菜。

LFgg非常非常非常挑剔，他只吃自家别墅地里由女仆长Cgg种的韭菜。

LFgg并不是特别特别特别能吃，所以他想知道，一块田中的一部分上有多少韭菜，能让他吃痛快却不至于浪费。

LFgg叫来女仆长Cgg，在地图上画给了Cgg很多区域，希望Cgg能去调查究竟区域中有多少韭菜。

女仆长Cgg已经很累很累很累了，他希望聪明的你们能帮帮他，他已经快被压榨到犭

田地可以被抽象为一个二维平面，每一个平面上的点上有一些韭菜。

区域可以被抽象为一个二维平面上的一片矩形。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{输入}
第一行一个正整数T,代表田地块数。

对于每块田地，第一行三个正整数n,m,q分别代表田地的长、宽以及询问次数。

接下来n行，每行m个正整数aij，表示该点的韭菜数。

接下来q行，每行四个正整数x1,y1,x2,y2代表待查矩形的左上角与右下角。

T≤10,n,m≤1000,q≤10000,0≤aij≤1e9,x1≤x2,y1≤y2.
注意：该平面的编号方式为，从上到下x从小到大，从左到右y从小到大。如下为n=2,m=3时的编号情况。

(1,1) (1,2) (1,3)

(2,1) (2,2) (2,3)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{输出}
对于每块田地，首先输出一个“Field #t:”，表示第t组田地。(注意，Field后有空格，冒号后没有空格)

对于每次询问，首先输出“Case #q: ”，表示第q组询问，然后输出∑i=x1x2∑j=y1y2aij，即矩形内所有点的和（包括边上与顶点上）。（注意，Case后与冒号后均有空格）

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{示例}
输入：
\begin{lstlisting}
1
4 4 3
1 2 3 1
1 5 3 2
2 3 1 4
3 5 6 2
1 1 1 1
2 2 3 3
3 4 4 4
\end{lstlisting}

输出：
\begin{lstlisting}
Field #1:
Case #1: 1
Case #2: 12
Case #3: 6
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{题解}
二维前缀和，开一个二维数组

记$sum[x][y]$表示左上角为$(1, 1)$右下角为$(x, y)$的矩阵$a$中所有元素的和

即$sum[x][y] = \sum\limits_{i = 1}^{x}\sum\limits_{j = 1}^{y}{a[i][j]}$

$sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]$，可由此式求出整个$sum$数组

对于每次询问:

$\sum\limits_{i = x_1}^{x_2}\sum\limits_{j = y_1}^{y_2}{a[i][j]} = sum[x_2][y_2] - sum[x_1 - 1][y_2] - sum[x_2][y_1 - 1] + sum[x_1 - 1][y_1 - 1]$

即为每次询问的答案

具体的讲解和证明可以百度学习，这里放一个[链接](https://blog.csdn.net/Zeolim/article/details/86770827)

时间复杂度：$O(max(n^2, q))$

注意：如果维护每一行(列)的一维前缀和再每次累加也可过(因复杂度略大，可能只有C++可过)，时间复杂度：$O(max(nq, nm))$

