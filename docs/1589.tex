\subsection{题面}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Time Limit}
1s

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Memory Limit}
128M

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{题目}
网络流问题是XCPC比赛中重要的图论算法问题，一般用于解决流网络中的最大流量问题。考虑到许多同学没有学过图论，我们可以把这个问题形象地描述为如下问题：

网络中由两台计算机s和t，现在想从s传输数据到t。该网络中一共有n台计算机，其中一些计算机之间连有一条单向的通信电缆，每条通信电缆都有对应的1秒钟内所能传输的最大数据量。当其他计算机之间没有数据传输时，在一秒钟内s最多可以传送多少数据到t？*

单纯的贪心算法，不断找到一条从s到t的电缆路径，并尽可能多的传输数据，并不能总是找到该类问题的最优解。

像如下的网络，如果我沿着s->1->2->t传输5M数据，s->1->3->t传输5M数据,每秒一共只能传输10M数据，但是如果沿着s->1->3->t传输6M数据，s->1->2->t传输4M数据，s->2->t传输1M数据。就可以传输11M数据。

[图片（待上传）]

网络流算法需要对于每一个电缆，建立一个虚拟的方向相反的电缆，然后循环进行以下基本步骤：

1) 只利用当前流量小于最大数据量的电缆或者有流量流过的电缆的对应反向电缆，找到一条从s到t的电缆路径。

2) 如果不存在满足条件的路径，则结束。否则沿着该路径尽可能多的传输数据，返回上一步。（当然，反向电缆上的流量不可大于正向电缆当前的流量。）

具体证明方法并不在此赘述。

现在，我将在某一个图中进行上述算法每次循环找到的路径和路径上每秒发送的数据包大小告诉你，需要你告诉我最后形成的实际方案是什么？

注意：对于某一条单向电缆E，设其起点和终点为u和v,如果在给定的路径中从u到v每秒传输a大小的数据包，从v到u到传输大小为b的数据包，则在实际解决方案中我们给这条电缆安排的流量为a-b。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{输入}
第一行两个整数n和m，表示n台计算机和m条电缆。(1≤n≤200,1≤m≤n∗(n−1)/2)
接下来m行，每行3个整数u,v,c，表示存在一条从u到v的单向电缆，其最大数据量为c。(1≤u,v≤n,1≤c≤100)。保证不存在两条电缆他们的起点和终点与另一条相同或他们的起点和终点与另一条相反，也不存在起点终点相同的电缆。

之后一行一个整数k，表示提供的路径数目。保证都是合法的路径，且起点和终点始终一致。

第i行有两个整数ai和bi，表示第i条流量为ai，会经过bi个计算机。之后跟随bi个整数，表示依次经过的计算机编号.(1≤ai≤100,1≤bi≤n)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{输出}
输出m行，每行三个整数u,v,f，表示u到v的电缆最终空闲数据包为f。

不允许行末空格以及多余的回车。

电缆的输出顺序请按照输入顺序输出。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{示例}
输入：
\begin{lstlisting}
5 7
4 1 10
1 3 6
3 5 8
1 2 6
3 2 3
2 5 5
4 2 2
3
5 4 4 1 2 5
5 4 4 1 3 5
1 5 4 2 1 3 5
\end{lstlisting}

输出：
\begin{lstlisting}
4 1 0
1 3 0
3 5 2
1 2 2
3 2 3
2 5 0
4 2 1
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{题解}
（网络流好难，但是这个题倒是很简单）。

与其说这个题目是一个网络流题，不如说这是一个阅读理解题。给定一个有向图和有向图生
成的最大流路径，我们需要求它的剩余网络，本质上就是一个减法题：前者减去后者即为题
目的解。

\subsubsection{参考代码的解释}
解释 \ref{1589:ckdm} 节的参考代码，我们首先读入一个图到序列 $A$ 中，并生成图 $G$
（使用邻接矩阵表示）；之后 $t$ 次，每一次读入一个求解最大流过程中的路径，并减去
$G$ 图中对应边的流量（同时增加对应边的反向边的流量，从而维持两者和不变）；再使用
$A$ 的顺序，输出相减后的结果。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{参考代码}
\label{1589:ckdm}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

#define F(x) (#x) << ": " << (x) << ", "

struct {
  ll u, v, c;
} A[20010];
ll B[210];
ll G[210][210];

int main() {
  ll n, m;
  memset(G, 0, sizeof(G));
  scanf("%lld %lld", &n, &m);
  for (ll i = 0; i < m; i++) {
    scanf("%lld %lld %lld", &A[i].u, &A[i].v, &A[i].c);
    G[A[i].u][A[i].v] += A[i].c;
  }

  ll t;
  for (scanf("%lld", &t); t--;) {
    ll a, b;
    scanf("%lld %lld", &a, &b);
    for (ll i = 0; i < b; i++) {
      scanf("%lld", &B[i]);
    }
    for (ll i = 1; i < b; i++) {
      G[B[i - 1]][B[i]] -= a;
      G[B[i]][B[i - 1]] += a;
    }
  }

  for (ll i = 0; i < m; i++) {
    printf("%lld %lld %lld
", A[i].u, A[i].v, G[A[i].u][A[i].v]);
  }

  return 0;
}
\end{lstlisting}
