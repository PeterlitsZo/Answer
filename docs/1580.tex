\subsection{题面}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Time Limit}
2s

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Memory Limit}
128M

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{题目}
“啊！！！我的秀发”

众所周知，cgg有一头乌黑透亮的秀发。在期中复习前夕，cgg在自习室复习计网时又掉了
一些头发，这让他十分伤心。巧合的是，cgg掉落下来的头发有规律的排成了 \verb|'('| 
和 \verb|')'| 组成的序列，也就是左右括号。作为一个字符串选手，cgg最不能容忍这个
序列不是合法括号序列了，你帮助他使得这个括号序列变为合法括号序列吗？

对于给定的括号序列，你可以进行任意次数以下操作：
\begin{enumerate}
    \item 删除字符串中任意一个字符，消耗能量 $a$ 点。举例：\verb|'())'|$\to$%
        \verb|'()'|
    \item 将字符串的最前面一个字符移动到最后面，消耗能量 $b$ 点。举例：%
        \verb|')()()'|$\to$\verb|'()())'|
\end{enumerate}

以上操作不限顺序，不限次数。

合法括号序列：
\begin{enumerate}
    \item 空字符串是合法括号序列
    \item 如果s是合法括号序列，\verb|'('+s+')'|也是合法括号序列
    \item 如果s和t是合法括号序列，那么s+t也是合法括号序列
\end{enumerate}

例：\verb|'(()())()'|，\verb|'(())'|，\verb|'()()'|，\verb|'()'|是合法括号序列，
\verb|'())'|，\verb|')('|，\verb|')'|不是合法括号序列

输入保证字符串中仅含有左括号 \verb|'('| 和右括号 \verb|')'|
你可以消耗尽量少的能量使其变为合法括号序列吗？

输出消耗的最小能量，若无法消除，输出-1。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{输入}
第一行 $t$，表示共有 $t$ 组样例

每组输入两行，第一行为 $l$，$a$，$b$，$1 \leq l \leq 100000$，$1 \leq a$，$b \leq
1000000000$，分别为cgg掉落头发的根数，进行1操作需要的能量，进行2操作需要的能量，
第二行为一个字符串，输入保证字符串中仅含有\verb|'('|，\verb|')'|。

输入保证 $\sum l \leq 100000$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{输出}
对于每组样例输出需要消耗的最小能量，若无法消除输出-1。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{示例}
输入：
\begin{lstlisting}
3
5 2 1
)))((
2 5 12
)(
2 1 10
()
\end{lstlisting}

输出：
\begin{lstlisting}
4
10
0
\end{lstlisting}

首先对于两种操作，即将最左边的字符移动到最右边和删除一个字符，两者是完全独立的，两个操作之前不会相互影响，所以可以看做：先将最左边的$i$个字符移动到最右边，再对这个字符串进行删除操作，求出对于每个$i$所需的最小代价，取最小值，即为答案。注意：答案不会是$-1$，因为你总能够删除所有字符使其变为空串(空串也是合法括号序列)

这里有一个小技巧，你可以将两个相同的字符串进行拼接，像滑动窗口一样每次向右滑动一个，即可得到所有情况。例：$abcbc \rightarrow abcbcabcbc$，所有的情况为$[abcbc]abcbc,a[bcbca]bcbc,ab[cbcab]cbc,abc[bcabc]bc,abcb[cabcb]c$

所以现在问题变成：对于一段括号序列仅进行删除操作，如何使得删除次数最少并使得其变为合法括号序列？

记$f(s)$为使字符串$s$变为合法括号序列的最小删除次数，由上面的讨论可知答案为：$i\times b + f(s_i), \ for\ i\ from\ 0\ to\ n-1$，$s_i$为进行完移动操作以后的字符串。

对于一个括号序列，显然可以$O(len(s))$判断最小删除次数，方法：从前往后扫，遇到相匹配的$($和$)$就消除，最终变为$)...)(...($的形式，维护当前不匹配的$)$和最后剩下的$($即可，如果每次都这样判的话，总复杂度为$O(n^2)$，会$tle$

对于上面的方法，他的一个等价方法是：

1. $($代表$1$，$)$代表$-1$，用一个数组$a$维护当前的前缀和。比如$))()($对应的$a$为$[-1, -2, -1, -2]$

2. 当前删除的最小字符个数满足

   $$num= \begin{cases} a[n]& {if \ min(a) \geq 0}\\ a[n] - 2 \times min(a)& {if \ min(a) < 0} \end{cases}$$

所以滑动窗口每次往右移，你只需要求出这个窗口中的最小值以及最后一个值即可，注意因为当前$a[i]...a[i + n - 1]$的值还受$a[1]...a[i - 1]$的影响，所以还要维护一个$base$，每次询问消除这个影响。

当前窗口的最后一个值显然为$a[i + n - 1] + base$，可以$O(1)$询问

对于当前窗口中的最小值，有以下两种方法：

1. 线段树维护区间最值，复杂度$O(logn)$，不会的同学可以去学习一下
2. 考虑滑动窗口从$a[i]...a[i + n - 1]$滑动到$a[i + 1]...a[i + n]$这个过程中最小值的变化
   - 假如$s[i] = ($，则对于$s[i + 1]...s[i + n]$的前缀和中$s[i]...s[i + n - 1]$的前缀和相对之前减去了$1$，这一段的最小值也减去了$1$，$s[i + n] = s[i] = ($，所以$s[i + n]$的前缀和值比$s[i + n - 1]$的前缀和值大$1$，所以当前窗口最小值尽可能取这两个值，即为$nowmin = min(premin - 1, a[i] + base)$
   - 假如$s[i] = )$，证明与上面类似，$nowmin = min(premin + 1, a[i] + base)$，$nowmin$：当前字符串前缀和数组的最小值，$premin$：上一个状态字符串前缀和数组的最小值
   - 每次循环过后更新$base,nowmin$
   - 时间复杂度：$O(1)$

所以第一种写法的复杂度：$O(nlogn)$

第二种写法的复杂度：$O(n)$
